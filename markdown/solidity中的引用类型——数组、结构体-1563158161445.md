[Solidity英文文档连接](http://solidity.readthedocs.io/en/latest/index.html)

[Solidity简体中文文档连接](http://solidity-cn.readthedocs.io/zh/develop/)

[Solidity编辑器Remix](https://remix.ethereum.org/)

[Solidity关键字索引](http://solidity.readthedocs.io/en/latest/genindex.html)

[中文文档](https://solidity-cn.readthedocs.io/zh/develop/types.html#index-13)

[英文文档](https://solidity.readthedocs.io/en/latest/types.html#reference-types)

文章目录
####引用类型简介
- solidity中数据分类
- solidity中数据存储方式
- solidity中数据存储位置
- solidity中引用类型传值形式
#### 数组
- 数组种类
- 数组元素
- 数组成员
- 创建内存数组
- 字面量数组/内联数组
#### 结构体

-------------------------------------------------------------

##引用类型简介
####solidity中数据分类

- 值类型：常见的`uint`、`bool`等，值类型数据的传递总是copy
- 引用类型：常见的数组、结构体等（通常占用空间超过256位），引用类型的存储、传值有多总情况，下面会一一介绍

####solidity中数据存储方式

- memory：内存，这种形式存储的数据会在合约销毁时被回收
- storage：可以理解为在区块链上永久存储
- calldata：这种存储比较特殊，此种方式存储的数据是只读的，但不会永久存储，效果跟memory差不多，通常用来存储外部函数的参数（非返回参数）并且是强制的

####solidity中数据存储位置

大多数时候不同类型数据有默认的位置，另外也可以通过关键字`storage`、`memory`修改数据位置
下面是Solidity中引用类型数据的位置

|数据类型|位置|
|---|---|
|状态变量|强制指定位置storage，不可自定义|
|局部变量|默认位置storage，可自定义|
|函数参数（包括返回的参数）|默认位置memory，可自定义|
|外部函数参数（非返回参数）|强制指定位置calldata，不可自定义|

####solidity引用类型传值形式

引用类型之间值传递有两种形式，一种是copy（创建一份新的），一种是引用（内存地址赋值，类似于指针）

结合官方文档上的例子理解一下数据存储位置与值传递方式

```
pragma solidity ^0.4.0;

contract C {
    uint[] x; // 状态变量x 的数据存储位置是 storage

    // memoryArray 的数据存储位置是 memory
    function f(uint[] memoryArray) public {
        x = memoryArray; // 将整个数组copy到 storage 中，可行
        var y = x;  // 分配一个指针（其中 y 的数据存储位置是 storage），可行
        y[7]; // 返回第 8 个元素，可行
        y.length = 2; // 通过 y 修改 x，可行
        delete x; // 清除数组，同时修改 y，可行
        // 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组， /
        // 但 storage 是“静态”分配的：
        // y = memoryArray;
        // 下面这一行也不可行，因为这会“重置”指针，
        // 但并没有可以让它指向的合适的存储位置。
        // delete y;

        g(x); // 调用 g 函数，同时移交对 x 的引用
        h(x); // 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝
    }
    
    function g(uint[] storage storageArray) internal {}  // 通过关键字强制将参数位置设置为storage
    function h(uint[] memoryArray) public {}
}
```

##数组
####数组种类

- 定长数组：长度固定，声明方式`T[K]`，数组元素类型为T，长度为K的定长数组
- 动态数组：长度可变，声明方式`T[]`, 数组元素类型为T的动态数组
- 二维数组：声明方式`T[][K]`，包含K个元素类型为T的动态数组的定长数组，类似于C中的二维数组，不同的是表示数组长度的标识是在后面

>1.二维数组元素访问和声明是相反的，例如访问第三个动态数组的第二个元素，表达式是x[2][1]

>2.外部函数中目前还不能使用多维数组

- 特殊数组`bytes`：`bytes`类似于`byte[]`，所以就是元素类型为`byte`的变长数组
- 特殊数组`string`：`string`与`bytes`相同，区别是`string`不允许用长度或索引来访问，稍后介绍

####数组元素

不同存储位置的数组中元素类型限制是不同的：
- storage形式存储的数组，元素类型可以是任意的（包括数组、映射和结构体）
- memory形式存储的数组，元素类型不可以是映射，如果数组做为public函数的参数，那么他只能是ABI类型

####数组成员

- `length`：表示当前数组的长度，动态数组可以在存储storage （而不是内存memory ）中通过改变成员变量 .length 改变数组大小。并不能通过访问超出当前数组长度的方式实现自动扩展数组的长度。 一经创建，内存memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）
- `push `：变长的storage存储数组以及`bytes`类型（`string`除外）拥有该成员，作用追加新的元素到数组末尾。 返回新的数组长度
- `pop `：变长的storage存储数组以及`bytes`类型（`string`除外）拥有该成员，作用数组末尾去掉一个元素

>如果想要访问字符串` s`，用 `bytes(s).length` / `bytes(s)[7] = 'x';`。 注意这时你访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。

####创建内存数组

可使用`new`关键字创建memory变长数组，注意不能通过修改成员变量 .length 改变memory数组的大小

```
pragma solidity ^0.4.16;

contract C {
    function f(uint len) public pure {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);
        // 这里我们有 a.length == 7 以及 b.length == len
        a[6] = 8;
    }
}
```
####字面量数组/内联数组（他俩是一种东西）

```[uint(1), 2, 3]```就是一个字面量数组，这种数组是memory存储的，并且不可以直接把他赋值给变量，所有不可以有下面的代码

```
uint[3] arr = [uint(1), 2, 3];
```
字面量数组的元素类型由其中元素决定，`[uint(1), 3, 4]`的类型是`uint[3] memory`
在solidity中字面量数组可以像下面这种方式使用

```
pragma solidity ^0.4.16;

contract C {
    function f() public pure {
        g([uint(1), 2, 3]);
    }
    function g(uint[3] memory) public pure {
        // ...
    }
}
```
定长memory数组不可以赋值给动态memory数组，下面的代码是不允许的

```
pragma solidity ^0.4.0;
contract C {
    function f() public {
       // 下面这句代码是不允许的
        uint[] memory x = [uint(1), 3, 4];
    }
}
```

####关于数组的一些小总结

- EVM的运行机制是栈的形式，memory存储实际是让EVM开辟一块区域（固定大小），临时存储一些东西，所以memory用于函数内部，这部分空间在执行之后会被回收
- 状态变量的最大作用就是表示合约的当前状态，是和合约共存亡的，所以这也是为什么状态都是storage存储，并且状态变量改变要花费gas
- 值类型的局部变量存储在栈中
- EVM机制有一条是外部函数不能返回动态内容，所以外部函数的返回值不可以是动态数组

##结构体

通过官方例子自行学习

```
pragma solidity ^0.4.11;

contract CrowdFunding {
    // 定义的新类型包含两个属性。
    struct Funder {
        address addr;
        uint amount;
    }

    struct Campaign {
        address beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    mapping (uint => Campaign) campaigns;

    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) {
        campaignID = numCampaigns++; // campaignID 作为一个变量返回
        // 创建新的结构体示例，存储在 storage 中。我们先不关注映射类型。
        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
    }

    function contribute(uint campaignID) public payable {
        Campaign storage c = campaigns[campaignID];
        // 以给定的值初始化，创建一个新的临时 memory 结构体，
        // 并将其拷贝到 storage 中。
        // 注意你也可以使用 Funder(msg.sender, msg.value) 来初始化。
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
        c.amount += msg.value;
    }

    function checkGoalReached(uint campaignID) public returns (bool reached) {
        Campaign storage c = campaigns[campaignID];
        if (c.amount < c.fundingGoal)
            return false;
        uint amount = c.amount;
        c.amount = 0;
        c.beneficiary.transfer(amount);
        return true;
    }
}
```

>1.结构体中可以包含任何类型，
>
>2.结构体不可包含自身
>
>3.函数内部将结构体赋值给一个storage存储的局部变量是引用赋值，不是copy，所以修改局部变量会修改结构体

